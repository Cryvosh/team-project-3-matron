# Team 3 - Matron

## Iteration 2 - Review & Retrospect

 * When: Thursday March 5, at 5:00pm
 * Where: Robarts Group Study Room 3

## Process - Reflection


#### Q1. Decisions that turned out well

The first successful decision we made was adopting [GitHub projects](https://github.com/csc301-winter-2020/team-project-3-matron/projects/1) as a mixed kanban/scrum style project management board. The rich integration with other GitHub features such as issues, commits, branches, and pull requests, all of which we made heavy use of, helped it to organize the project extremely well. The projects feature naturally worked as a Kanban board with different columns, cards for each task that also double as issues, and automatic card movement when pull requests are merged or issues are created. It also has a feature called milestones which helped us to organize our work into scrum-style weekly sprints and completion tracking. Overall, GitHub helped to keep us organized and on track.

The second successful decision was splitting up the different areas of the project into different roles that each team member was in charge of. This allowed development to happen in parallel which sped up the iteration process and allowed each of us to focus more closely on a specific part of the project to give it more polish. Also, having team members dedicated to areas such as testing and DevOps helped to create a much more more polished product with quicker deployment, so that the rest of the team only needed to worry about their own tasks.

Finally, using Discord for internal communication was also a good decision because it facilitated internal communication and increased organization in the team. Having multiple channels allowed important annoucements to quickly reach the entire team such as team meetings or any changes. We also had separate channels for different areas of the project such as the front end or the backend, which helped multiple subteams collaborate in parallel without disturbing the others. Also, since a team of 8 members isn't actually very large overall, we had most of our discussion in a group channel which meant that most of the team was up to date on the state of the project at any given team. This let us work at quite a fast face near the end of the deliverable when we were squashing bugs that needed input from people on many different subteams, and overall let the project be developed faster.

#### Q2. Decisions that did not turn out as well as we hoped
 
The first poor decision was to leave the project deployment until the end of the deliverable. The idea was that each person would develop their own features and we would integrate the components and deploy the project near the end once everyone had finished. In practice, this led to an inconsistent folder structure that resulted in many merge conflicts, as well as many bugs arising from the integration that now had to be fixed. In addition, some changes had to be made to the overall structure to get the project to work on Heroku which meant a late stage restructuring which took alot of time and introduced even more bugs. If we were to do the project again, we would start with a very basic Flask server and an established folder structure that we know would work with Heroku, and then split from there to each work on our own areas of the project.
 
Another poor planning decision was we made was to use Trello as our Kanban board instead of GitHub projects. Originally, this was because we were not aware that GitHub had it's own project management tool so for the first 2 weeks of the deliverable we were using a Trello page. The reason it worked poorly was because most of the team had never used Trello before, and it was a hassle to have to use an entirely separate service for the Kanban board. This meant that the team wasn't keeping it updated and checking in on it frequently, so the Trello page was frequently out of date and not very useful as a tool to track the overall team progress. When we eventually switched to GitHub projects, we found it worked much better with our workflow and organizational style.

Lastly, our decision to require 1 and 3 code reviews before pushing to the `develop` and `master` branches respectively wasnt as successful as we expected. While it was good that it forced the team to look at each other's code and ensured that no individual team member could mess up the branches, we found that it had a negative impact on the speed at which we could add features and go through iterations. Often in crunch times or when making quick bug fixes, the barrier of requiring a code review hindered more than helped us by distracting other team members who would have to approve the code without having the time to properly review it. As such, in practice, many would approve pull requests without testing or skimming them, effectively negating their upside. At one point we even temporarily disabled code reviews for `develop` to improve our efficiency but this proved unwise as an erroneous old version of the branch was somehow pushed to `develop` and broke it for a number of hours until the team leader woke up, enabled force pushing, and allowed us fix it via an overwrite with a working version. In the future, we plan to look into changing the number of code reviews needed or perhaps changing our branching habits which may help to alleviate the problem.

#### Q3. Planned changes
 
 One change we are planning to soon make relates to our project's documentation. As the codebase grows more complex and the API needs to be documented for future maintainability, we need to find a centralized place to write our documentation so that it's not just littered in various Discord messages and in our heads. Luckily, GitHub offers its free wiki page which works perfectly for our needs as it also integrates quite well with the other GitHub services we already use. In the coming weeks as we focus more on testing and polishing the product instead of adding new features, team members will be required to write documentation for the components they're in charge of to ensure all features and code is easy to understand.

As mentioned above, we plan to discuss and potentially vote on a new code review and branching system that both improves our efficiency in crunch time and ensures that bugs don't make it to master. We noticed that in a few cases, simply seeing the diffs (number of lines/files changed, etc.) of a pull request visually in Github allowed the commiter to notice a mistake in their pull request and correct it (eg., commiting unnecessary/old files). We discussed how it may be useful to set up a branch such that code reviews aren't explictly required, but pull requests must be merged through the Github interface so the commiter would be forced to see exactly what they've modified. However, as far as we can tell, no such option exists by default so we may need to enforce this through other means.

## Product - Review

#### Q4. How was your product demo?

We prepared our demo by loading a sample hospital map we prepared in advance to showcase the various features of our product. We went over many key features such as uploading a blueprint, making a new map, deleting nodes and edges, saving and retreiving maps, and finding distance between rooms. Our partner was happy with our progress, and aside from some bugs we found which we subsequently fixed, there were no major changes requesting aside from various UI tweaks as we polish up our design. One thing we learned was to practice the demo in advance to ensure no large bugs are found that break the flow of the demo and to rehearse which key features to showcase to keep things running smoothly. We also learned that to a non-technical user, it's important to have a simple and intuitive UI and to test the UI frequently to ensure it's not to difficult to use.

Crutially, we also learned during the demo that our software would most likely run on Internet Explorer or Edge browsers within a hospital setting and thus we'd need to test our code on such platforms to ensure that everything works.
